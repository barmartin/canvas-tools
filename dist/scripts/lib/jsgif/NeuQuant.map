{"version":3,"file":"NeuQuant.js","sources":["../../../../build/scripts/lib/jsgif/NeuQuant.js"],"names":["NeuQuant","alphadec","thepicture","lengthcount","samplefac","network","exports","netsize","prime1","prime2","prime3","prime4","minpicturebytes","maxnetpos","netbiasshift","ncycles","intbiasshift","intbias","gammashift","betashift","beta","betagamma","initrad","radiusbiasshift","radiusbias","initradius","radiusdec","alphabiasshift","initalpha","radbiasshift","radbias","alpharadbshift","alpharadbias","netindex","Array","bias","freq","radpower","thepic","len","sample","i","p","colorMap","map","index","k","l","j","inxbuild","smallpos","smallval","q","previouscol","startpos","learn","b","g","r","radius","rad","alpha","step","delta","samplepixels","pix","lim","contest","altersingle","alterneigh","unbiasnet","dist","a","bestd","best","process","lo","hi","m","e","n","biasdist","betafreq","bestpos","bestbiaspos","bestbiasd","apply","this","arguments"],"mappings":"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","sourcesContent":["/*\r\n* NeuQuant Neural-Net Quantization Algorithm\r\n* ------------------------------------------\r\n* \r\n* Copyright (c) 1994 Anthony Dekker\r\n* \r\n* NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n* \"Kohonen neural networks for optimal colour quantization\" in \"Network:\r\n* Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\r\n* the algorithm.\r\n* \r\n* Any party obtaining a copy of these files from the author, directly or\r\n* indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n* world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n* this software and documentation files (the \"Software\"), including without\r\n* limitation the rights to use, copy, modify, merge, publish, distribute,\r\n* sublicense, and/or sell copies of the Software, and to permit persons who\r\n* receive copies from any such party to do so, with the only requirement being\r\n* that this copyright notice remain intact.\r\n*/\r\n \r\n/*\r\n* This class handles Neural-Net quantization algorithm\r\n* @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n* @author Thibault Imbert (AS3 version - bytearray.org)\r\n* @version 0.1 AS3 implementation\r\n*/\r\n\r\n\t//import flash.utils.ByteArray;\r\n\t\r\n\tNeuQuant = function()\r\n\t{\r\n\t    var exports = {};\r\n\t\t/*private_static*/ var netsize/*int*/ = 256; /* number of colours used */\r\n\t\t\r\n\t\t/* four primes near 500 - assume no image has a length so large */\r\n\t\t/* that it is divisible by all four primes */\r\n\t\t\r\n\t\t/*private_static*/ var prime1/*int*/ = 499;\r\n\t\t/*private_static*/ var prime2/*int*/ = 491;\r\n\t\t/*private_static*/ var prime3/*int*/ = 487;\r\n\t\t/*private_static*/ var prime4/*int*/ = 503;\r\n\t\t/*private_static*/ var minpicturebytes/*int*/ = (3 * prime4);\r\n\t\t\r\n\t\t/* minimum size for input image */\r\n\t\t/*\r\n\t\t* Program Skeleton ---------------- [select samplefac in range 1..30] [read\r\n\t\t* image from input file] pic = (unsigned char*) malloc(3*width*height);\r\n\t\t* initnet(pic,3*width*height,samplefac); learn(); unbiasnet(); [write output\r\n\t\t* image header, using writecolourmap(f)] inxbuild(); write output image using\r\n\t\t* inxsearch(b,g,r)\r\n\t\t*/\r\n\r\n\t\t/*\r\n\t\t* Network Definitions -------------------\r\n\t\t*/\r\n\t\t\r\n\t\t/*private_static*/ var maxnetpos/*int*/ = (netsize - 1);\r\n\t\t/*private_static*/ var netbiasshift/*int*/ = 4; /* bias for colour values */\r\n\t\t/*private_static*/ var ncycles/*int*/ = 100; /* no. of learning cycles */\r\n\t\t\r\n\t\t/* defs for freq and bias */\r\n\t\t/*private_static*/ var intbiasshift/*int*/ = 16; /* bias for fractions */\r\n\t\t/*private_static*/ var intbias/*int*/ = (1 << intbiasshift);\r\n\t\t/*private_static*/ var gammashift/*int*/ = 10; /* gamma = 1024 */\r\n\t\t/*private_static*/ var gamma/*int*/ = (1 << gammashift);\r\n\t\t/*private_static*/ var betashift/*int*/ = 10;\r\n\t\t/*private_static*/ var beta/*int*/ = (intbias >> betashift); /* beta = 1/1024 */\r\n\t\t/*private_static*/ var betagamma/*int*/ = (intbias << (gammashift - betashift));\r\n\t\t\r\n\t\t/* defs for decreasing radius factor */\r\n\t\t/*private_static*/ var initrad/*int*/ = (netsize >> 3); /*\r\n\t                                                         * for 256 cols, radius\r\n\t                                                         * starts\r\n\t                                                         */\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \r\n\t\t/*private_static*/ var radiusbiasshift/*int*/ = 6; /* at 32.0 biased by 6 bits */\r\n\t\t/*private_static*/ var radiusbias/*int*/ = (1 << radiusbiasshift);\r\n\t\t/*private_static*/ var initradius/*int*/ = (initrad * radiusbias); /*\r\n\t                                                                   * and\r\n\t                                                                   * decreases\r\n\t                                                                   * by a\r\n\t                                                                   */\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \r\n\t\t/*private_static*/ var radiusdec/*int*/ = 30; /* factor of 1/30 each cycle */\r\n\t\t\r\n\t\t/* defs for decreasing alpha factor */\r\n\t\t/*private_static*/ var alphabiasshift/*int*/ = 10; /* alpha starts at 1.0 */\r\n\t\t/*private_static*/ var initalpha/*int*/ = (1 << alphabiasshift);\r\n\t\t/*private*/ var alphadec/*int*/ /* biased by 10 bits */\r\n\t\t\r\n\t\t/* radbias and alpharadbias used for radpower calculation */\r\n\t\t/*private_static*/ var radbiasshift/*int*/ = 8;\r\n\t\t/*private_static*/ var radbias/*int*/ = (1 << radbiasshift);\r\n\t\t/*private_static*/ var alpharadbshift/*int*/ = (alphabiasshift + radbiasshift);\r\n\t\t\r\n\t\t/*private_static*/ var alpharadbias/*int*/ = (1 << alpharadbshift);\r\n\t\t\r\n\t\t/*\r\n\t\t* Types and Global Variables --------------------------\r\n\t\t*/\r\n\t\t\r\n\t\t/*private*/ var thepicture/*ByteArray*//* the input image itself */\r\n\t\t/*private*/ var lengthcount/*int*/; /* lengthcount = H*W*3 */\r\n\t\t/*private*/ var samplefac/*int*/; /* sampling factor 1..30 */\r\n\t\t\r\n\t\t// typedef int pixel[4]; /* BGRc */\r\n\t\t/*private*/ var network/*Array*/; /* the network itself - [netsize][4] */\r\n\t\t/*protected*/ var netindex/*Array*/ = new Array();\r\n\t\t\r\n\t\t/* for network lookup - really 256 */\r\n\t\t/*private*/ var bias/*Array*/ = new Array();\r\n\t\t\r\n\t\t/* bias and freq arrays for learning */\r\n\t\t/*private*/ var freq/*Array*/ = new Array();\r\n\t\t/*private*/ var radpower/*Array*/ = new Array();\r\n\t\t\r\n\t\tvar NeuQuant = exports.NeuQuant = function NeuQuant(thepic/*ByteArray*/, len/*int*/, sample/*int*/)\r\n\t\t{\r\n\t\t\t\r\n\t\t\tvar i/*int*/;\r\n\t\t\tvar p/*Array*/;\r\n\t\t\t\r\n\t\t\tthepicture = thepic;\r\n\t\t\tlengthcount = len;\r\n\t\t\tsamplefac = sample;\r\n\t\t\t\r\n\t\t\tnetwork = new Array(netsize);\r\n\t\t\t\r\n\t\t\tfor (i = 0; i < netsize; i++)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tnetwork[i] = new Array(4);\r\n\t\t\t\tp = network[i];\r\n\t\t\t\tp[0] = p[1] = p[2] = (i << (netbiasshift + 8)) / netsize;\r\n\t\t\t\tfreq[i] = intbias / netsize; /* 1/netsize */\r\n\t\t\t\tbias[i] = 0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tvar colorMap = function colorMap()/*ByteArray*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\tvar map/*ByteArray*/ = [];\r\n\t\t    var index/*Array*/ = new Array(netsize);\r\n\t\t    for (var i/*int*/ = 0; i < netsize; i++)\r\n\t\t      index[network[i][3]] = i;\r\n\t\t    var k/*int*/ = 0;\r\n\t\t    for (var l/*int*/ = 0; l < netsize; l++) {\r\n\t\t      var j/*int*/ = index[l];\r\n\t\t      map[k++] = (network[j][0]);\r\n\t\t      map[k++] = (network[j][1]);\r\n\t\t      map[k++] = (network[j][2]);\r\n\t\t    }\r\n\t\t    return map;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t   * Insertion sort of network and building of netindex[0..255] (to do after\r\n\t   * unbias)\r\n\t   * -------------------------------------------------------------------------------\r\n\t   */\r\n\t   \r\n\t   var inxbuild = function inxbuild()/*void*/\r\n\t   {\r\n\t\t   \r\n\t\t  var i/*int*/;\r\n\t\t  var j/*int*/;\r\n\t\t  var smallpos/*int*/;\r\n\t\t  var smallval/*int*/;\r\n\t\t  var p/*Array*/;\r\n\t\t  var q/*Array*/;\r\n\t\t  var previouscol/*int*/\r\n\t\t  var startpos/*int*/\r\n\t\t  \r\n\t\t  previouscol = 0;\r\n\t\t  startpos = 0;\r\n\t\t  for (i = 0; i < netsize; i++)\r\n\t\t  {\r\n\t\t\t  \r\n\t\t\t  p = network[i];\r\n\t\t\t  smallpos = i;\r\n\t\t\t  smallval = p[1]; /* index on g */\r\n\t\t\t  /* find smallest in i..netsize-1 */\r\n\t\t\t  for (j = i + 1; j < netsize; j++)\r\n\t\t\t  {\r\n\t\t\t\t  q = network[j];\r\n\t\t\t\t  if (q[1] < smallval)\r\n\t\t\t\t  { /* index on g */\r\n\t\t\t\t  \r\n\t\t\t\t\tsmallpos = j;\r\n\t\t\t\t\tsmallval = q[1]; /* index on g */\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t\t  q = network[smallpos];\r\n\t\t\t  /* swap p (i) and q (smallpos) entries */\r\n\t\t\t  \r\n\t\t\t  if (i != smallpos)\r\n\t\t\t  {\r\n\t\t\t\t  \r\n\t\t\t\t  j = q[0];\r\n\t\t\t\t  q[0] = p[0];\r\n\t\t\t\t  p[0] = j;\r\n\t\t\t\t  j = q[1];\r\n\t\t\t\t  q[1] = p[1];\r\n\t\t\t\t  p[1] = j;\r\n\t\t\t\t  j = q[2];\r\n\t\t\t\t  q[2] = p[2];\r\n\t\t\t\t  p[2] = j;\r\n\t\t\t\t  j = q[3];\r\n\t\t\t\t  q[3] = p[3];\r\n\t\t\t\t  p[3] = j;\r\n\t\t\t\t  \r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t\t  /* smallval entry is now in position i */\r\n\t\t\t  \r\n\t\t\t  if (smallval != previouscol)\r\n\t\t\t  \r\n\t\t\t  {\r\n\t\t\t\t  \r\n\t\t\t\tnetindex[previouscol] = (startpos + i) >> 1;\r\n\t\t\t\t  \r\n\t\t\t\tfor (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\r\n\t\t\t\t  \r\n\t\t\t\tpreviouscol = smallval;\r\n\t\t\t\tstartpos = i;\r\n\t\t\t\t\r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tnetindex[previouscol] = (startpos + maxnetpos) >> 1;\r\n\t\t\tfor (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos; /* really 256 */\r\n\t\t\t\r\n\t   }\r\n\t   \r\n\t   /*\r\n\t   * Main Learning Loop ------------------\r\n\t   */\r\n\t   \r\n\t   var learn = function learn()/*void*/ \r\n\t   \r\n\t   {\r\n\t\t   \r\n\t\t   var i/*int*/;\r\n\t\t   var j/*int*/;\r\n\t\t   var b/*int*/;\r\n\t\t   var g/*int*/\r\n\t\t   var r/*int*/;\r\n\t\t   var radius/*int*/;\r\n\t\t   var rad/*int*/;\r\n\t\t   var alpha/*int*/;\r\n\t\t   var step/*int*/;\r\n\t\t   var delta/*int*/;\r\n\t\t   var samplepixels/*int*/;\r\n\t\t   var p/*ByteArray*/;\r\n\t\t   var pix/*int*/;\r\n\t\t   var lim/*int*/;\r\n\t\t   \r\n\t\t   if (lengthcount < minpicturebytes) samplefac = 1;\r\n\t\t   \r\n\t\t   alphadec = 30 + ((samplefac - 1) / 3);\r\n\t\t   p = thepicture;\r\n\t\t   pix = 0;\r\n\t\t   lim = lengthcount;\r\n\t\t   samplepixels = lengthcount / (3 * samplefac);\r\n\t\t   delta = (samplepixels / ncycles) | 0;\r\n\t\t   alpha = initalpha;\r\n\t\t   radius = initradius;\r\n\t\t   \r\n\t\t   rad = radius >> radiusbiasshift;\r\n\t\t   if (rad <= 1) rad = 0;\r\n\t\t   \r\n\t\t   for (i = 0; i < rad; i++) radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\r\n\t\t   \r\n\t\t   \r\n\t\t   if (lengthcount < minpicturebytes) step = 3;\r\n\t\t   \r\n\t\t   else if ((lengthcount % prime1) != 0) step = 3 * prime1;\r\n\t\t   \r\n\t\t   else\r\n\t\t   \r\n\t\t   {\r\n\t\t\t   \r\n\t\t\t   if ((lengthcount % prime2) != 0) step = 3 * prime2;\r\n\t\t\t   \r\n\t\t\t   else\r\n\t\t\t   \r\n\t\t\t   {\r\n\t\t\t\t   \r\n\t\t\t\t   if ((lengthcount % prime3) != 0) step = 3 * prime3;\r\n\t\t\t\t   \r\n\t\t\t\t   else step = 3 * prime4;\r\n\t\t\t\t   \r\n\t\t\t   }\r\n\t\t\t   \r\n\t\t   }\r\n\t\t   \r\n\t\t   i = 0;\r\n\t\t   \r\n\t\t   while (i < samplepixels)\r\n\t\t   \r\n\t\t   {\r\n\t\t\t   \r\n\t\t\t   b = (p[pix + 0] & 0xff) << netbiasshift;\r\n\t\t\t   g = (p[pix + 1] & 0xff) << netbiasshift;\r\n\t\t\t   r = (p[pix + 2] & 0xff) << netbiasshift;\r\n\t\t\t   j = contest(b, g, r);\r\n\t\t\t   \r\n\t\t\t   altersingle(alpha, j, b, g, r);\r\n\t\t\t   \r\n\t\t\t   if (rad != 0) alterneigh(rad, j, b, g, r); /* alter neighbours */\r\n\t\t\t   \r\n\t\t\t   pix += step;\r\n\t\t\t   \r\n\t\t\t   if (pix >= lim) pix -= lengthcount;\r\n\t\t\t   \r\n\t\t\t   i++;\r\n\t\t\t   \r\n\t\t\t   if (delta == 0) delta = 1;\r\n\t\t\t   \r\n\t\t\t   if (i % delta == 0)\r\n\t\t\t   \r\n\t\t\t   {\r\n\t\t\t\t   \r\n\t\t\t\t   alpha -= alpha / alphadec;\r\n\t\t\t\t   radius -= radius / radiusdec;\r\n\t\t\t\t   rad = radius >> radiusbiasshift;\r\n\t\t\t\t   \r\n\t\t\t\t   if (rad <= 1) rad = 0;\r\n\t\t\t\t   \r\n\t\t\t\t   for (j = 0; j < rad; j++) radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\r\n\t\t\t\t   \r\n\t\t\t   }\r\n\t\t\t   \r\n\t\t   }\r\n\t\t   \r\n\t   }\r\n\t   \r\n\t   /*\r\n\t   ** Search for BGR values 0..255 (after net is unbiased) and return colour\r\n\t   * index\r\n\t   * ----------------------------------------------------------------------------\r\n\t   */\r\n\t   \r\n\t   var map = exports.map = function map(b/*int*/, g/*int*/, r/*int*/)/*int*/\r\n\t  \r\n\t   {\r\n\t\t   \r\n\t\t   var i/*int*/;\r\n\t\t   var j/*int*/;\r\n\t\t   var dist/*int*/\r\n\t\t   var a/*int*/;\r\n\t\t   var bestd/*int*/;\r\n\t\t   var p/*Array*/;\r\n\t\t   var best/*int*/;\r\n\t\t   \r\n\t\t   bestd = 1000; /* biggest possible dist is 256*3 */\r\n\t\t   best = -1;\r\n\t\t   i = netindex[g]; /* index on g */\r\n\t\t   j = i - 1; /* start at netindex[g] and work outwards */\r\n\t\r\n\t    while ((i < netsize) || (j >= 0))\r\n\t\t\r\n\t\t{\r\n\t\t\t\r\n\t\t\tif (i < netsize)\r\n\t\t\t\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tp = network[i];\r\n\t\t\t\t\r\n\t\t\t\tdist = p[1] - g; /* inx key */\r\n\t\t\t\t\r\n\t\t\t\tif (dist >= bestd) i = netsize; /* stop iter */\r\n\t\t\t\t\r\n\t\t\t\telse\r\n\t\t\t\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (dist < 0) dist = -dist;\r\n\t\t\t\t\t\r\n\t\t\t\t\ta = p[0] - b;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (a < 0) a = -a;\r\n\t\t\t\t\t\r\n\t\t\t\t\tdist += a;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (dist < bestd)\r\n\t\t\t\t\t\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\ta = p[2] - r;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (a < 0) a = -a;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdist += a;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (dist < bestd)\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbestd = dist;\r\n\t\t\t\t\t\t\tbest = p[3];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t  \r\n\t      if (j >= 0)\r\n\t\t  {\r\n\t\t\t  \r\n\t\t\t  p = network[j];\r\n\t\t\t  \r\n\t\t\t  dist = g - p[1]; /* inx key - reverse dif */\r\n\t\t\t  \r\n\t\t\t  if (dist >= bestd) j = -1; /* stop iter */\r\n\t\t\t  \r\n\t\t\t  else \r\n\t\t\t  {\r\n\t\t\t\t  \r\n\t\t\t\t  j--;\r\n\t\t\t\t  if (dist < 0) dist = -dist;\r\n\t\t\t\t  a = p[0] - b;\r\n\t\t\t\t  if (a < 0) a = -a;\r\n\t\t\t\t  dist += a;\r\n\t\t\t\t  \r\n\t\t\t\t  if (dist < bestd)\r\n\t\t\t\t  \r\n\t\t\t\t  {\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  a = p[2] - r;\r\n\t\t\t\t\t  if (a < 0)a = -a;\r\n\t\t\t\t\t  dist += a;\r\n\t\t\t\t\t  if (dist < bestd)\r\n\t\t\t\t\t  {\r\n\t\t\t\t\t\t  bestd = dist;\r\n\t\t\t\t\t\t  best = p[3];\r\n\t\t\t\t\t  }\r\n\t\t\t\t\t  \r\n\t\t\t\t  }\r\n\t\t\t\t  \r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t  }\r\n\t\t  \r\n\t\t}\r\n\t\t\r\n\t    return (best);\r\n\t\t\r\n\t  }\r\n\t  \r\n\t  var process = exports.process = function process()/*ByteArray*/\r\n\t  {\r\n\t   \r\n\t    learn();\r\n\t    unbiasnet();\r\n\t    inxbuild();\r\n\t    return colorMap();\r\n\t\t\r\n\t  }\r\n\t  \r\n\t  /*\r\n\t  * Unbias network to give byte values 0..255 and record position i to prepare\r\n\t  * for sort\r\n\t  * -----------------------------------------------------------------------------------\r\n\t  */\r\n\t  \r\n\t  var unbiasnet = function unbiasnet()/*void*/\r\n\t  \r\n\t  {\r\n\t\r\n\t    var i/*int*/;\r\n\t    var j/*int*/;\r\n\t\r\n\t    for (i = 0; i < netsize; i++)\r\n\t\t{\r\n\t      network[i][0] >>= netbiasshift;\r\n\t      network[i][1] >>= netbiasshift;\r\n\t      network[i][2] >>= netbiasshift;\r\n\t      network[i][3] = i; /* record colour no */\r\n\t    }\r\n\t\t\r\n\t  }\r\n\t  \r\n\t  /*\r\n\t  * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in\r\n\t  * radpower[|i-j|]\r\n\t  * ---------------------------------------------------------------------------------\r\n\t  */\r\n\t  \r\n\t  var alterneigh = function alterneigh(rad/*int*/, i/*int*/, b/*int*/, g/*int*/, r/*int*/)/*void*/\r\n\t  \r\n\t  {\r\n\t\t  \r\n\t\t  var j/*int*/;\r\n\t\t  var k/*int*/;\r\n\t\t  var lo/*int*/;\r\n\t\t  var hi/*int*/;\r\n\t\t  var a/*int*/;\r\n\t\t  var m/*int*/;\r\n\t\t  \r\n\t\t  var p/*Array*/;\r\n\t\t  \r\n\t\t  lo = i - rad;\r\n\t\t  if (lo < -1) lo = -1;\r\n\t\t  \r\n\t\t  hi = i + rad;\r\n\t\t  \r\n\t\t  if (hi > netsize) hi = netsize;\r\n\t\t  \r\n\t\t  j = i + 1;\r\n\t\t  k = i - 1;\r\n\t\t  m = 1;\r\n\t\t  \r\n\t\t  while ((j < hi) || (k > lo))\r\n\t\t  \r\n\t\t  {\r\n\t\t\t  \r\n\t\t\t  a = radpower[m++];\r\n\t\t\t  \r\n\t\t\t  if (j < hi)\r\n\t\t\t  \r\n\t\t\t  {\r\n\t\t\t\t  \r\n\t\t\t\t  p = network[j++];\r\n\t\t\t\t  \r\n\t\t\t\t  try {\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  p[0] -= (a * (p[0] - b)) / alpharadbias;\r\n\t\t\t\t\t  p[1] -= (a * (p[1] - g)) / alpharadbias;\r\n\t\t\t\t\t  p[2] -= (a * (p[2] - r)) / alpharadbias;\r\n\t\t\t\t\t  \r\n\t\t\t\t\t  } catch (e/*Error*/) {} // prevents 1.3 miscompilation\r\n\t\t\t\t\t  \r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (k > lo)\r\n\t\t\t\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\tp = network[k--];\r\n\t\t\t\t\t\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tp[0] -= (a * (p[0] - b)) / alpharadbias;\r\n\t\t\t\t\t\tp[1] -= (a * (p[1] - g)) / alpharadbias;\r\n\t\t\t\t\t\tp[2] -= (a * (p[2] - r)) / alpharadbias;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} catch (e/*Error*/) {}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t  }\r\n\t\t  \r\n\t  }\r\n\t  \r\n\t  /*\r\n\t  * Move neuron i towards biased (b,g,r) by factor alpha\r\n\t  * ----------------------------------------------------\r\n\t  */\r\n\t  \r\n\t  var altersingle = function altersingle(alpha/*int*/, i/*int*/, b/*int*/, g/*int*/, r/*int*/)/*void*/ \r\n\t  {\r\n\t\t  \r\n\t\t  /* alter hit neuron */\r\n\t\t  var n/*Array*/ = network[i];\r\n\t\t  n[0] -= (alpha * (n[0] - b)) / initalpha;\r\n\t\t  n[1] -= (alpha * (n[1] - g)) / initalpha;\r\n\t\t  n[2] -= (alpha * (n[2] - r)) / initalpha;\r\n\t\t\r\n\t  }\r\n\t  \r\n\t  /*\r\n\t  * Search for biased BGR values ----------------------------\r\n\t  */\r\n\t  \r\n\t  var contest = function contest(b/*int*/, g/*int*/, r/*int*/)/*int*/\r\n\t  {\r\n\t\t  \r\n\t\t  /* finds closest neuron (min dist) and updates freq */\r\n\t\t  /* finds best neuron (min dist-bias) and returns position */\r\n\t\t  /* for frequently chosen neurons, freq[i] is high and bias[i] is negative */\r\n\t\t  /* bias[i] = gamma*((1/netsize)-freq[i]) */\r\n\t\t  \r\n\t\t  var i/*int*/;\r\n\t\t  var dist/*int*/;\r\n\t\t  var a/*int*/;\r\n\t\t  var biasdist/*int*/;\r\n\t\t  var betafreq/*int*/;\r\n\t\t  var bestpos/*int*/;\r\n\t\t  var bestbiaspos/*int*/;\r\n\t\t  var bestd/*int*/;\r\n\t\t  var bestbiasd/*int*/;\r\n\t\t  var n/*Array*/;\r\n\t\t  \r\n\t\t  bestd = ~(1 << 31);\r\n\t\t  bestbiasd = bestd;\r\n\t\t  bestpos = -1;\r\n\t\t  bestbiaspos = bestpos;\r\n\t\t  \r\n\t\t  for (i = 0; i < netsize; i++)\r\n\t\t  \r\n\t\t  {\r\n\t\t\t  \r\n\t\t\t  n = network[i];\r\n\t\t\t  dist = n[0] - b;\r\n\t\t\t  \r\n\t\t\t  if (dist < 0) dist = -dist;\r\n\t\t\t  \r\n\t\t\t  a = n[1] - g;\r\n\t\t\t  \r\n\t\t\t  if (a < 0) a = -a;\r\n\t\t\t  \r\n\t\t\t  dist += a;\r\n\t\t\t  \r\n\t\t\t  a = n[2] - r;\r\n\t\t\t  \r\n\t\t\t  if (a < 0) a = -a;\r\n\t\t\t  \r\n\t\t\t  dist += a;\r\n\t\t\t  \r\n\t\t\t  if (dist < bestd)\r\n\t\t\t  \r\n\t\t\t  {\r\n\t\t\t\t  \r\n\t\t\t\t  bestd = dist;\r\n\t\t\t\t  bestpos = i;\r\n\t\t\t\t  \r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t\t  biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\r\n\t\t\t  \r\n\t\t\t  if (biasdist < bestbiasd)\r\n\t\t\t  \r\n\t\t\t  {\r\n\t\t\t\t  \r\n\t\t\t\t  bestbiasd = biasdist;\r\n\t\t\t\t  bestbiaspos = i;\r\n\t\t\t\t  \r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t\t  betafreq = (freq[i] >> betashift);\r\n\t\t\t  freq[i] -= betafreq;\r\n\t\t\t  bias[i] += (betafreq << gammashift);\r\n\t\t\t  \r\n\t\t  }\r\n\t\t  \r\n\t\t  freq[bestpos] += beta;\r\n\t\t  bias[bestpos] -= betagamma;\r\n\t\t  return (bestbiaspos);\r\n\t\t  \r\n\t  }\r\n\t  \r\n\t  NeuQuant.apply(this, arguments);\r\n\t  return exports;\r\n\t}\r\n"]}