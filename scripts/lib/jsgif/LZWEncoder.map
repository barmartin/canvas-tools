{"version":3,"file":"LZWEncoder.js","sources":["../../../../build/scripts/lib/jsgif/LZWEncoder.js"],"names":["LZWEncoder","imgW","imgH","pixAry","initCodeSize","remaining","curPixel","n_bits","maxcode","g_init_bits","ClearCode","EOFCode","a_count","exports","EOF","BITS","HSIZE","maxbits","maxmaxcode","htab","Array","codetab","hsize","free_ent","clear_flg","cur_accum","cur_bits","masks","accum","width","height","pixels","color_depth","Math","max","char_out","c","outs","flush_char","cl_block","cl_hash","output","i","compress","init_bits","fcode","ent","disp","hsize_reg","hshift","MAXCODE","nextPixel","outer_loop","encode","os","writeByte","writeBytes","pix","code","apply","this","arguments"],"mappings":"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","sourcesContent":["/**\r\n* This class handles LZW encoding\r\n* Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\r\n* @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n* @author Thibault Imbert (AS3 version - bytearray.org)\r\n* @version 0.1 AS3 implementation\r\n*/\r\n\r\n\t//import flash.utils.ByteArray;\r\n\t\r\n\tLZWEncoder = function()\r\n\t{\r\n\t    var exports = {};\r\n\t\t/*private_static*/ var EOF/*int*/ = -1;\r\n\t\t/*private*/ var imgW/*int*/;\r\n\t\t/*private*/ var imgH/*int*/\r\n\t\t/*private*/ var pixAry/*ByteArray*/;\r\n\t\t/*private*/ var initCodeSize/*int*/;\r\n\t\t/*private*/ var remaining/*int*/;\r\n\t\t/*private*/ var curPixel/*int*/;\r\n\t\t\r\n\t\t// GIFCOMPR.C - GIF Image compression routines\r\n\t\t// Lempel-Ziv compression based on 'compress'. GIF modifications by\r\n\t\t// David Rowley (mgardi@watdcsu.waterloo.edu)\r\n\t\t// General DEFINEs\r\n\t\t\r\n\t\t/*private_static*/ var BITS/*int*/ = 12;\r\n\t\t/*private_static*/ var HSIZE/*int*/ = 5003; // 80% occupancy\r\n\t\t\r\n\t\t// GIF Image compression - modified 'compress'\r\n\t\t// Based on: compress.c - File compression ala IEEE Computer, June 1984.\r\n\t\t// By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\r\n\t\t// Jim McKie (decvax!mcvax!jim)\r\n\t\t// Steve Davies (decvax!vax135!petsd!peora!srd)\r\n\t\t// Ken Turkowski (decvax!decwrl!turtlevax!ken)\r\n\t\t// James A. Woods (decvax!ihnp4!ames!jaw)\r\n\t\t// Joe Orost (decvax!vax135!petsd!joe)\r\n\t\t\r\n\t\t/*private*/ var n_bits/*int*/ // number of bits/code\r\n\t\t/*private*/ var maxbits/*int*/ = BITS; // user settable max # bits/code\r\n\t\t/*private*/ var maxcode/*int*/ // maximum code, given n_bits\r\n\t\t/*private*/ var maxmaxcode/*int*/ = 1 << BITS; // should NEVER generate this code\r\n\t\t/*private*/ var htab/*Array*/ = new Array;\r\n\t\t/*private*/ var codetab/*Array*/ = new Array;\r\n\t\t/*private*/ var hsize/*int*/ = HSIZE; // for dynamic table sizing\r\n\t\t/*private*/ var free_ent/*int*/ = 0; // first unused entry\r\n\t\t\r\n\t\t// block compression parameters -- after all codes are used up,\r\n\t\t// and compression rate changes, start over.\r\n\t\t\r\n\t\t/*private*/ var clear_flg/*Boolean*/ = false;\r\n\t\t\r\n\t\t// Algorithm: use open addressing double hashing (no chaining) on the\r\n\t\t// prefix code / next character combination. We do a variant of Knuth's\r\n\t\t// algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\r\n\t\t// secondary probe. Here, the modular division first probe is gives way\r\n\t\t// to a faster exclusive-or manipulation. Also do block compression with\r\n\t\t// an adaptive reset, whereby the code table is cleared when the compression\r\n\t\t// ratio decreases, but after the table fills. The variable-length output\r\n\t\t// codes are re-sized at this point, and a special CLEAR code is generated\r\n\t\t// for the decompressor. Late addition: construct the table according to\r\n\t\t// file size for noticeable speed improvement on small files. Please direct\r\n\t\t// questions about this implementation to ames!jaw.\r\n\t\t\r\n\t\t/*private*/ var g_init_bits/*int*/;\r\n\t\t/*private*/ var ClearCode/*int*/;\r\n\t\t/*private*/ var EOFCode/*int*/;\r\n\t\t\r\n\t\t// output\r\n\t\t// Output the given code.\r\n\t\t// Inputs:\r\n\t\t// code: A n_bits-bit integer. If == -1, then EOF. This assumes\r\n\t\t// that n_bits =< wordsize - 1.\r\n\t\t// Outputs:\r\n\t\t// Outputs code to the file.\r\n\t\t// Assumptions:\r\n\t\t// Chars are 8 bits long.\r\n\t\t// Algorithm:\r\n\t\t// Maintain a BITS character long buffer (so that 8 codes will\r\n\t\t// fit in it exactly). Use the VAX insv instruction to insert each\r\n\t\t// code in turn. When the buffer fills up empty it and start over.\r\n\t\t\r\n\t\t/*private*/ var cur_accum/*int*/ = 0;\r\n\t\t/*private*/ var cur_bits/*int*/ = 0;\r\n\t\t/*private*/ var masks/*Array*/ = [ 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF ];\r\n\t\t\r\n\t\t// Number of characters so far in this 'packet'\r\n\t\t/*private*/ var a_count/*int*/;\r\n\t\t\r\n\t\t// Define the storage for the packet accumulator\r\n\t\t/*private*/ var accum/*ByteArray*/ = [];\r\n\t\t\r\n\t\tvar LZWEncoder = exports.LZWEncoder = function LZWEncoder (width/*int*/, height/*int*/, pixels/*ByteArray*/, color_depth/*int*/)\r\n\t\t{\r\n\t\t\t\r\n\t\t\timgW = width;\r\n\t\t\timgH = height;\r\n\t\t\tpixAry = pixels;\r\n\t\t\tinitCodeSize = Math.max(2, color_depth);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// Add a character to the end of the current packet, and if it is 254\r\n\t\t// characters, flush the packet to disk.\r\n\t\tvar char_out = function char_out(c/*Number*/, outs/*ByteArray*/)/*void*/\r\n\t\t{\r\n\t\t\taccum[a_count++] = c;\r\n\t\t\tif (a_count >= 254) flush_char(outs);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// Clear out the hash table\r\n\t\t// table clear for block compress\r\n\t\t\r\n\t\tvar cl_block = function cl_block(outs/*ByteArray*/)/*void*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\tcl_hash(hsize);\r\n\t\t\tfree_ent = ClearCode + 2;\r\n\t\t\tclear_flg = true;\r\n\t\t\toutput(ClearCode, outs);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// reset code table\r\n\t\tvar cl_hash = function cl_hash(hsize/*int*/)/*void*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\tfor (var i/*int*/ = 0; i < hsize; ++i) htab[i] = -1;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tvar compress = exports.compress = function compress(init_bits/*int*/, outs/*ByteArray*/)/*void*/\r\n\t\t\r\n\t\t{\r\n\t\t\tvar fcode/*int*/;\r\n\t\t\tvar i/*int*/ /* = 0 */;\r\n\t\t\tvar c/*int*/;\r\n\t\t\tvar ent/*int*/;\r\n\t\t\tvar disp/*int*/;\r\n\t\t\tvar hsize_reg/*int*/;\r\n\t\t\tvar hshift/*int*/;\r\n\t\t\t\r\n\t\t\t// Set up the globals: g_init_bits - initial number of bits\r\n\t\t\tg_init_bits = init_bits;\r\n\t\t\t\r\n\t\t\t// Set up the necessary values\r\n\t\t\tclear_flg = false;\r\n\t\t\tn_bits = g_init_bits;\r\n\t\t\tmaxcode = MAXCODE(n_bits);\r\n\t\r\n\t\t\tClearCode = 1 << (init_bits - 1);\r\n\t\t\tEOFCode = ClearCode + 1;\r\n\t\t\tfree_ent = ClearCode + 2;\r\n\t\r\n\t\t\ta_count = 0; // clear packet\r\n\t\t\r\n\t\t\tent = nextPixel();\r\n\t\r\n\t\t\thshift = 0;\r\n\t\t\tfor (fcode = hsize; fcode < 65536; fcode *= 2)\r\n\t\t\t  ++hshift;\r\n\t\t\thshift = 8 - hshift; // set hash code range bound\r\n\t\r\n\t\t\thsize_reg = hsize;\r\n\t\t\tcl_hash(hsize_reg); // clear hash table\r\n\t\t\r\n\t\t\toutput(ClearCode, outs);\r\n\t\t\r\n\t\t\touter_loop: while ((c = nextPixel()) != EOF)\r\n\t\t\t\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tfcode = (c << maxbits) + ent;\r\n\t\t\t\ti = (c << hshift) ^ ent; // xor hashing\r\n\t\r\n\t\t\t\tif (htab[i] == fcode)\r\n\t\t\t\t{\r\n\t\t\t\tent = codetab[i];\r\n\t\t\t\tcontinue;\r\n\t\t\t\t} else if (htab[i] >= 0) // non-empty slot\r\n\t\t\t\t{\r\n\t\t\t\t\tdisp = hsize_reg - i; // secondary hash (after G. Knott)\r\n\t\t\t\t\tif (i == 0)\r\n\t\t\t\t\tdisp = 1;\r\n\t\t\t\t\tdo \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif ((i -= disp) < 0) i += hsize_reg;\r\n\t\r\n\t\t\t\t\t\tif (htab[i] == fcode)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\tent = codetab[i];\r\n\t\t\t\t\t\tcontinue outer_loop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} while (htab[i] >= 0);\r\n\t\t\t\t}\r\n\t      \r\n\t\t\t\toutput(ent, outs);\r\n\t\t\t\tent = c;\r\n\t\t\t\tif (free_ent < maxmaxcode)\r\n\t\t\t\t{\r\n\t\t\t\t\tcodetab[i] = free_ent++; // code -> hashtable\r\n\t\t\t\t\thtab[i] = fcode;\r\n\t\t\t\t} else cl_block(outs);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Put out the final code.\r\n\t\t\toutput(ent, outs);\r\n\t\t\toutput(EOFCode, outs);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// ----------------------------------------------------------------------------\r\n\t\tvar encode = exports.encode = function encode(os/*ByteArray*/)/*void*/\r\n\t\t{\r\n\t\t\tos.writeByte(initCodeSize); // write \"initial code size\" byte\r\n\t\t\tremaining = imgW * imgH; // reset navigation variables\r\n\t\t\tcurPixel = 0;\r\n\t\t\tcompress(initCodeSize + 1, os); // compress and write the pixel data\r\n\t\t\tos.writeByte(0); // write block terminator\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// Flush the packet to disk, and reset the accumulator\r\n\t\tvar flush_char = function flush_char(outs/*ByteArray*/)/*void*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\tif (a_count > 0)\r\n\t\t\t{\r\n\t\t\t\touts.writeByte(a_count);\r\n\t\t\t\touts.writeBytes(accum, 0, a_count);\r\n\t\t\t\ta_count = 0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tvar MAXCODE = function MAXCODE(n_bits/*int*/)/*int*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\treturn (1 << n_bits) - 1;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// ----------------------------------------------------------------------------\r\n\t\t// Return the next pixel from the image\r\n\t\t// ----------------------------------------------------------------------------\r\n\t\t\r\n\t\tvar nextPixel = function nextPixel()/*int*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\tif (remaining == 0) return EOF;\r\n\t\t\t\r\n\t\t\t--remaining;\r\n\t\t\t\r\n\t\t\tvar pix/*Number*/ = pixAry[curPixel++];\r\n\t\t\t\r\n\t\t\treturn pix & 0xff;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tvar output = function output(code/*int*/, outs/*ByteArray*/)/*void*/\r\n\t\t\r\n\t\t{\r\n\t\t\tcur_accum &= masks[cur_bits];\r\n\t\t\t\r\n\t\t\tif (cur_bits > 0) cur_accum |= (code << cur_bits);\r\n\t\t\telse cur_accum = code;\r\n\t\t\t\r\n\t\t\tcur_bits += n_bits;\r\n\t\t\t\r\n\t\t\twhile (cur_bits >= 8)\r\n\t\t\t\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tchar_out((cur_accum & 0xff), outs);\r\n\t\t\t\tcur_accum >>= 8;\r\n\t\t\t\tcur_bits -= 8;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// If the next entry is going to be too big for the code size,\r\n\t\t\t// then increase it, if possible.\r\n\t\t\t\r\n\t\t\tif (free_ent > maxcode || clear_flg)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tif (clear_flg)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\tmaxcode = MAXCODE(n_bits = g_init_bits);\r\n\t\t\t\t\tclear_flg = false;\r\n\t\t\t\t\t\r\n\t\t\t\t} else\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\t++n_bits;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (n_bits == maxbits) maxcode = maxmaxcode;\r\n\t\t\t\t\t\r\n\t\t\t\t\telse maxcode = MAXCODE(n_bits);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (code == EOFCode) \r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\t// At EOF, write the rest of the buffer.\r\n\t\t\t\twhile (cur_bits > 0) \r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\tchar_out((cur_accum & 0xff), outs);\r\n\t\t\t\t\tcur_accum >>= 8;\r\n\t\t\t\t\tcur_bits -= 8;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tflush_char(outs);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\tLZWEncoder.apply(this, arguments);\r\n\t   return exports;\r\n\t}\r\n\t\r\n"]}