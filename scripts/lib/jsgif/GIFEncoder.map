{"version":3,"file":"GIFEncoder.js","sources":["../../../../build/scripts/lib/jsgif/GIFEncoder.js"],"names":["GIFEncoder","ByteArray","this","bin","i","chr","String","fromCharCode","prototype","getData","v","l","length","writeByte","val","push","writeUTFBytes","string","charCodeAt","writeBytes","array","offset","width","height","transIndex","out","image","pixels","indexedPixels","colorDepth","colorTab","exports","transparent","repeat","delay","started","usedEntry","Array","palSize","dispose","closeStream","firstFrame","sizeSet","sample","comment","reset","setDelay","ms","Math","round","setDispose","code","setRepeat","iter","setTransparent","c","setComment","addFrame","im","is_imageData","Error","ok","getImageData","canvas","data","setSize","getImagePixels","analyzePixels","writeLSD","writePalette","writeNetscapeExt","writeGraphicCtrlExt","writeCommentExt","writeImageDesc","writePixels","e","finish","setFrameRate","fps","setQuality","quality","w","h","start","cont","len","nPix","nq","NeuQuant","process","k","j","index","map","findClosest","r","g","b","minpos","dmin","dr","dg","db","d","count","transp","disp","WriteShort","n","pValue","myencoder","LZWEncoder","encode","stream","setProperties","has_start","is_first"],"mappings":"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","sourcesContent":["/**\r\n* This class lets you encode animated GIF files\r\n* Base class :  http://www.java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm\r\n* @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n* @author Thibault Imbert (AS3 version - bytearray.org)\r\n* @version 0.1 AS3 implementation\r\n*/\r\n\r\n\r\n\t//import flash.utils.ByteArray;\r\n\t//import flash.display.BitmapData;\r\n\t//import flash.display.Bitmap;\r\n\t//import org.bytearray.gif.encoder.NeuQuant\r\n\t//import flash.net.URLRequestHeader;\r\n\t//import flash.net.URLRequestMethod;\r\n\t//import flash.net.URLRequest;\r\n\t//import flash.net.navigateToURL;\r\n\t\r\n\tGIFEncoder = function()\r\n\t{\r\n\t    for(var i = 0, chr = {}; i < 256; i++)\r\n        chr[i] = String.fromCharCode(i);\r\n        \r\n      function ByteArray(){\r\n        this.bin = [];\r\n      }\r\n\r\n      ByteArray.prototype.getData = function(){\r\n        \r\n\t      for(var v = '', l = this.bin.length, i = 0; i < l; i++)\r\n          v += chr[this.bin[i]];\r\n        return v;\r\n      }\r\n      ByteArray.prototype.writeByte = function(val){\r\n        this.bin.push(val);\r\n      }\r\n      ByteArray.prototype.writeUTFBytes = function(string){\r\n        for(var l = string.length, i = 0; i < l; i++)\r\n          this.writeByte(string.charCodeAt(i));\r\n      }\r\n      ByteArray.prototype.writeBytes = function(array, offset, length){\r\n        for(var l = length || array.length, i = offset||0; i < l; i++)\r\n          this.writeByte(array[i]);\r\n      }\r\n\t\r\n\t    var exports = {};\r\n\t\t/*private*/ var width/*int*/ // image size\r\n  \t\t/*private*/ var height/*int*/;\r\n\t    /*private*/ var transparent/***/ = null; // transparent color if given\r\n\t    /*private*/ var transIndex/*int*/; // transparent index in color table\r\n\t    /*private*/ var repeat/*int*/ = -1; // no repeat\r\n\t    /*private*/ var delay/*int*/ = 0; // frame delay (hundredths)\r\n\t    /*private*/ var started/*Boolean*/ = false; // ready to output frames\r\n\t    /*private*/ var out/*ByteArray*/;\r\n\t    /*private*/ var image/*Bitmap*/; // current frame\r\n\t    /*private*/ var pixels/*ByteArray*/; // BGR byte array from frame\r\n\t    /*private*/ var indexedPixels/*ByteArray*/ // converted frame indexed to palette\r\n\t    /*private*/ var colorDepth/*int*/; // number of bit planes\r\n\t    /*private*/ var colorTab/*ByteArray*/; // RGB palette\r\n\t    /*private*/ var usedEntry/*Array*/ = new Array; // active palette entries\r\n\t    /*private*/ var palSize/*int*/ = 7; // color table size (bits-1)\r\n\t    /*private*/ var dispose/*int*/ = -1; // disposal code (-1 = use default)\r\n\t    /*private*/ var closeStream/*Boolean*/ = false; // close stream when finished\r\n\t    /*private*/ var firstFrame/*Boolean*/ = true;\r\n\t    /*private*/ var sizeSet/*Boolean*/ = false; // if false, get size from first frame\r\n\t    /*private*/ var sample/*int*/ = 10; // default sample interval for quantizer\r\n\t    /*private*/ var comment/*string*/ = \"Generated by jsgif (https://github.com/antimatter15/jsgif/)\"; // default comment for generated gif\r\n\t\t\r\n\t\t/**\r\n\t\t* Sets the delay time between each frame, or changes it for subsequent frames\r\n\t\t* (applies to last frame added)\r\n\t\t* int delay time in milliseconds\r\n\t\t* @param ms\r\n\t\t*/\r\n\t\t\r\n\t\tvar setDelay = exports.setDelay = function setDelay(ms/*int*/)/*void*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\tdelay = Math.round(ms / 10);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Sets the GIF frame disposal code for the last added frame and any\r\n\t\t* \r\n\t\t* subsequent frames. Default is 0 if no transparent color has been set,\r\n\t\t* otherwise 2.\r\n\t\t* @param code\r\n\t\t* int disposal code.\r\n\t\t*/\r\n\t\t\r\n\t\tvar setDispose = exports.setDispose = function setDispose(code/*int*/)/*void*/ \r\n\t\t{\r\n\t\t\t\r\n\t\t\tif (code >= 0) dispose = code;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Sets the number of times the set of GIF frames should be played. Default is\r\n\t\t* 1; 0 means play indefinitely. Must be invoked before the first image is\r\n\t\t* added.\r\n\t\t* \r\n\t\t* @param iter\r\n\t\t* int number of iterations.\r\n\t\t* @return\r\n\t\t*/\r\n\t\t\r\n\t\tvar setRepeat = exports.setRepeat = function setRepeat(iter/*int*/)/*void*/ \r\n\t\t{\r\n\t\t\t\r\n\t\t\tif (iter >= 0) repeat = iter;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Sets the transparent color for the last added frame and any subsequent\r\n\t\t* frames. Since all colors are subject to modification in the quantization\r\n\t\t* process, the color in the final palette for each frame closest to the given\r\n\t\t* color becomes the transparent color for that frame. May be set to null to\r\n\t\t* indicate no transparent color.\r\n\t\t* @param\r\n\t\t* Color to be treated as transparent on display.\r\n\t\t*/\r\n\t\t\r\n\t\tvar setTransparent = exports.setTransparent = function setTransparent(c/*Number*/)/*void*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\ttransparent = c;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t       /**\t\t\r\n\t\t* Sets the comment for the block comment\r\n\t\t* @param\r\n\t\t* string to be insterted as comment\r\n\t\t*/\r\n\t\tvar setComment = exports.setComment = function setComment(c/*string*/)\r\n\t\t{\r\n\t\t    comment = c;\r\n\t\t}\r\n\r\n\t\t\r\n\t\t\r\n\t\t/**\r\n\t\t* The addFrame method takes an incoming BitmapData object to create each frames\r\n\t\t* @param\r\n\t\t* BitmapData object to be treated as a GIF's frame\r\n\t\t*/\r\n\t\t\r\n\t\tvar addFrame = exports.addFrame = function addFrame(im/*BitmapData*/, is_imageData)/*Boolean*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\tif ((im == null) || !started || out == null) \r\n\t\t\t{\r\n\t\t\t\tthrow new Error (\"Please call start method before calling addFrame\");\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t    var ok/*Boolean*/ = true;\r\n\t\t\t\r\n\t\t    try {\r\n\t\t\t\tif(!is_imageData){\r\n\t\t\t\t  image = im.getImageData(0,0, im.canvas.width, im.canvas.height).data;\r\n\t\t\t\t  if (!sizeSet) setSize(im.canvas.width, im.canvas.height);\r\n\t\t\t\t}else{\r\n\t\t\t\t  image = im;\r\n\t\t\t\t}\r\n\t\t\t\tgetImagePixels(); // convert to correct format if necessary\r\n\t\t\t\tanalyzePixels(); // build color table & map pixels\r\n\t\t\t\t\r\n\t\t\t\tif (firstFrame) \r\n\t\t\t\t{\r\n\t\t\t\t\twriteLSD(); // logical screen descriptior\r\n\t\t\t\t\twritePalette(); // global color table\r\n\t\t\t\t\tif (repeat >= 0) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// use NS app extension to indicate reps\r\n\t\t\t\t\t\twriteNetscapeExt();\r\n\t\t\t\t\t}\r\n\t\t      }\r\n\t\t\t  \r\n\t\t\t  writeGraphicCtrlExt(); // write graphic control extension\r\n\t\t\t  if(comment!='') {\r\n\t\t\t    writeCommentExt(); // write comment extension\r\n\t\t\t  }\r\n\t\t      writeImageDesc(); // image descriptor\r\n\t\t      if (!firstFrame) writePalette(); // local color table\r\n\t\t      writePixels(); // encode and write pixel data\r\n\t\t      firstFrame = false;\r\n\t\t    } catch (e/*Error*/) {\r\n\t\t      ok = false;\r\n\t\t    }\r\n\t\t    \r\n\t\t\treturn ok;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Adds final trailer to the GIF stream, if you don't call the finish method\r\n\t\t* the GIF stream will not be valid.\r\n\t\t*/\r\n\t\t\r\n\t\tvar finish = exports.finish = function finish()/*Boolean*/\r\n\t\t{\r\n\t\t    if (!started) return false;\r\n\t\t    var ok/*Boolean*/ = true;\r\n\t\t    started = false;\r\n\t\t    try {\r\n\t\t      out.writeByte(0x3b); // gif trailer\r\n\t\t    } catch (e/*Error*/) {\r\n\t\t      ok = false;\r\n\t\t    }\r\n\t\r\n\t\t    return ok;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Resets some members so that a new stream can be started.\r\n\t\t* This method is actually called by the start method\r\n\t\t*/\r\n\t\t\r\n\t\tvar reset = function reset ( )/*void*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\t// reset for subsequent use\r\n\t\t\ttransIndex = 0;\r\n\t\t\timage = null;\r\n\t\t    pixels = null;\r\n\t\t    indexedPixels = null;\r\n\t\t    colorTab = null;\r\n\t\t    closeStream = false;\r\n\t\t    firstFrame = true;\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* * Sets frame rate in frames per second. Equivalent to\r\n\t\t* <code>setDelay(1000/fps)</code>.\r\n\t\t* @param fps\r\n\t\t* float frame rate (frames per second)         \r\n\t\t*/\r\n\t\t\r\n\t\tvar setFrameRate = exports.setFrameRate = function setFrameRate(fps/*Number*/)/*void*/ \r\n\t\t{\r\n\t\t\t\r\n\t\t\tif (fps != 0xf) delay = Math.round(100/fps);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Sets quality of color quantization (conversion of images to the maximum 256\r\n\t\t* colors allowed by the GIF specification). Lower values (minimum = 1)\r\n\t\t* produce better colors, but slow processing significantly. 10 is the\r\n\t\t* default, and produces good color mapping at reasonable speeds. Values\r\n\t\t* greater than 20 do not yield significant improvements in speed.\r\n\t\t* @param quality\r\n\t\t* int greater than 0.\r\n\t\t* @return\r\n\t\t*/\r\n\t\t\r\n\t\tvar setQuality = exports.setQuality = function setQuality(quality/*int*/)/*void*/\r\n\t\t{\r\n\t\t\t\r\n\t\t    if (quality < 1) quality = 1;\r\n\t\t    sample = quality;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Sets the GIF frame size. The default size is the size of the first frame\r\n\t\t* added if this method is not invoked.\r\n\t\t* @param w\r\n\t\t* int frame width.\r\n\t\t* @param h\r\n\t\t* int frame width.\r\n\t\t*/\r\n\t\t\r\n\t\tvar setSize = exports.setSize = function setSize(w/*int*/, h/*int*/)/*void*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\tif (started && !firstFrame) return;\r\n\t\t    width = w;\r\n\t\t    height = h;\r\n\t\t    if (width < 1)width = 320;\r\n\t\t    if (height < 1)height = 240;\r\n\t\t    sizeSet = true\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Initiates GIF file creation on the given stream.\r\n\t\t* @param os\r\n\t\t* OutputStream on which GIF images are written.\r\n\t\t* @return false if initial write failed.\r\n\t\t* \r\n\t\t*/\r\n\t\t\r\n\t\tvar start = exports.start = function start()/*Boolean*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\treset(); \r\n\t\t    var ok/*Boolean*/ = true;\r\n\t\t    closeStream = false;\r\n\t\t    out = new ByteArray;\r\n\t\t    try {\r\n\t\t      out.writeUTFBytes(\"GIF89a\"); // header\r\n\t\t    } catch (e/*Error*/) {\r\n\t\t      ok = false;\r\n\t\t    }\r\n\t\t\t\r\n\t\t    return started = ok;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tvar cont = exports.cont = function cont()/*Boolean*/\r\n\t\t{\r\n\t\t\t\r\n\t\t    reset(); \r\n\t\t    var ok/*Boolean*/ = true;\r\n\t\t    closeStream = false;\r\n\t\t    out = new ByteArray;\r\n\t\t\t\r\n\t\t    return started = ok;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Analyzes image colors and creates color map.\r\n\t\t*/\r\n\t\t\r\n\t\tvar analyzePixels = function analyzePixels()/*void*/\r\n\t\t{\r\n\t\t    \r\n\t\t\tvar len/*int*/ = pixels.length;\r\n\t\t    var nPix/*int*/ = len / 3;\r\n\t\t    indexedPixels = [];\r\n\t\t    var nq/*NeuQuant*/ = new NeuQuant(pixels, len, sample);\r\n\t\t    // initialize quantizer\r\n\t\t    colorTab = nq.process(); // create reduced palette\r\n\t\t    // map image pixels to new palette\r\n\t\t    var k/*int*/ = 0;\r\n\t\t    for (var j/*int*/ = 0; j < nPix; j++) {\r\n\t\t      var index/*int*/ = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);\r\n\t\t      usedEntry[index] = true;\r\n\t\t      indexedPixels[j] = index;\r\n\t\t    }\r\n\t\t    pixels = null;\r\n\t\t    colorDepth = 8;\r\n\t\t    palSize = 7;\r\n\t\t    // get closest match to transparent color if specified\r\n\t\t    if (transparent != null) {\r\n\t\t      transIndex = findClosest(transparent);\r\n\t\t    }\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Returns index of palette color closest to c\r\n\t\t*\r\n\t\t*/\r\n\t\t\r\n\t\tvar findClosest = function findClosest(c/*Number*/)/*int*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\tif (colorTab == null) return -1;\r\n\t\t    var r/*int*/ = (c & 0xFF0000) >> 16;\r\n\t\t    var g/*int*/ = (c & 0x00FF00) >> 8;\r\n\t\t    var b/*int*/ = (c & 0x0000FF);\r\n\t\t    var minpos/*int*/ = 0;\r\n\t\t    var dmin/*int*/ = 256 * 256 * 256;\r\n\t\t    var len/*int*/ = colorTab.length;\r\n\t\t\t\r\n\t\t    for (var i/*int*/ = 0; i < len;) {\r\n\t\t      var dr/*int*/ = r - (colorTab[i++] & 0xff);\r\n\t\t      var dg/*int*/ = g - (colorTab[i++] & 0xff);\r\n\t\t      var db/*int*/ = b - (colorTab[i] & 0xff);\r\n\t\t      var d/*int*/ = dr * dr + dg * dg + db * db;\r\n\t\t      var index/*int*/ = i / 3;\r\n\t\t      if (usedEntry[index] && (d < dmin)) {\r\n\t\t        dmin = d;\r\n\t\t        minpos = index;\r\n\t\t      }\r\n\t\t      i++;\r\n\t\t    }\r\n\t\t    return minpos;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Extracts image pixels into byte array \"pixels\r\n\t\t*/\r\n\t\t\r\n\t\tvar getImagePixels = function getImagePixels()/*void*/\r\n\t\t{\r\n\t\t    \r\n\t\t    var w/*int*/ = width;\r\n\t\t    var h/*int*/ = height;\r\n\t\t    pixels = [];\r\n  \t\t\tvar data = image;\r\n\t\t    var count/*int*/ = 0;\r\n\t\t    \r\n\t\t    for ( var i/*int*/ = 0; i < h; i++ )\r\n\t\t    {\r\n\t\t    \t\r\n\t\t    \tfor (var j/*int*/ = 0; j < w; j++ )\r\n\t\t    \t{\r\n\t\t    \t\t\r\n\t        \t\tvar b = (i*w*4)+j*4;\r\n\t        \t\tpixels[count++] = data[b];\r\n\t        \t\tpixels[count++] = data[b+1];\r\n\t        \t\tpixels[count++] = data[b+2];\r\n\t\t    \t\t\r\n\t\t    \t}\r\n\t\t    \t\r\n\t\t    }\r\n\t\t    \r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Writes Graphic Control Extension\r\n\t\t*/\r\n\t\t\r\n\t\tvar writeGraphicCtrlExt = function writeGraphicCtrlExt()/*void*/\r\n\t\t{\r\n\t\t\tout.writeByte(0x21); // extension introducer\r\n\t\t    out.writeByte(0xf9); // GCE label\r\n\t\t    out.writeByte(4); // data block size\r\n\t\t    var transp/*int*/\r\n\t\t    var disp/*int*/;\r\n\t\t    if (transparent == null) {\r\n\t\t      transp = 0;\r\n\t\t      disp = 0; // dispose = no action\r\n\t\t    } else {\r\n\t\t      transp = 1;\r\n\t\t      disp = 2; // force clear if using transparent color\r\n\t\t    }\r\n\t\t    if (dispose >= 0) {\r\n\t\t      disp = dispose & 7; // user override\r\n\t\t    }\r\n\t\t    disp <<= 2;\r\n\t\t    // packed fields\r\n\t\t    out.writeByte(0 | // 1:3 reserved\r\n\t\t        disp | // 4:6 disposal\r\n\t\t        0 | // 7 user input - 0 = none\r\n\t\t        transp); // 8 transparency flag\r\n\t\t\r\n\t\t    WriteShort(delay); // delay x 1/100 sec\r\n\t\t    out.writeByte(transIndex); // transparent color index\r\n\t\t    out.writeByte(0); // block terminator\r\n\t\t\t\r\n\t\t}\r\n\t\t  \r\n\t\t/**\r\n\t\t* Writes Comment Extention\r\n\t\t*/\r\n\t\tvar writeCommentExt = function writeCommentExt()/*void*/\r\n\t\t{\r\n\t\t\r\n\t\t    out.writeByte(0x21); // extension introducer\r\n\t\t    out.writeByte(0xfe); // comment label\r\n\t\t    out.writeByte(comment.length); // Block Size (s)\r\n\t\t    out.writeUTFBytes(comment);\r\n\t\t    out.writeByte(0); // block terminator\r\n        \t}\t\t\r\n\t\t  \r\n\t\t  \r\n\t\t/**\r\n\t\t* Writes Image Descriptor\r\n\t\t*/\r\n\t\t\r\n\t\tvar writeImageDesc = function writeImageDesc()/*void*/\r\n\t\t{\r\n\t\t  \t\r\n\t\t    out.writeByte(0x2c); // image separator\r\n\t\t   \tWriteShort(0); // image position x,y = 0,0\r\n\t\t    WriteShort(0);\r\n\t\t    WriteShort(width); // image size\r\n\t\t    WriteShort(height);\r\n\r\n\t\t    // packed fields\r\n\t\t    if (firstFrame) {\r\n\t\t      // no LCT - GCT is used for first (or only) frame\r\n\t\t      out.writeByte(0);\r\n\t\t    } else {\r\n\t\t      // specify normal LCT\r\n\t\t      out.writeByte(0x80 | // 1 local color table 1=yes\r\n\t\t          0 | // 2 interlace - 0=no\r\n\t\t          0 | // 3 sorted - 0=no\r\n\t\t          0 | // 4-5 reserved\r\n\t\t          palSize); // 6-8 size of color table\r\n\t\t    }\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Writes Logical Screen Descriptor\r\n\t\t*/\r\n\t\t\r\n\t\tvar writeLSD = function writeLSD()/*void*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\t// logical screen size\r\n\t\t    WriteShort(width);\r\n\t\t    WriteShort(height);\r\n\t\t    // packed fields\r\n\t\t    out.writeByte((0x80 | // 1 : global color table flag = 1 (gct used)\r\n\t\t        0x70 | // 2-4 : color resolution = 7\r\n\t\t        0x00 | // 5 : gct sort flag = 0\r\n\t\t        palSize)); // 6-8 : gct size\r\n\t\t\r\n\t\t    out.writeByte(0); // background color index\r\n\t\t    out.writeByte(0); // pixel aspect ratio - assume 1:1\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Writes Netscape application extension to define repeat count.\r\n\t\t*/\r\n\t\t\r\n\t\tvar writeNetscapeExt = function writeNetscapeExt()/*void*/\r\n\t\t{\r\n\t\t\t\r\n\t\t    out.writeByte(0x21); // extension introducer\r\n\t\t    out.writeByte(0xff); // app extension label\r\n\t\t    out.writeByte(11); // block size\r\n\t\t    out.writeUTFBytes(\"NETSCAPE\" + \"2.0\"); // app id + auth code\r\n\t\t    out.writeByte(3); // sub-block size\r\n\t\t    out.writeByte(1); // loop sub-block id\r\n\t\t    WriteShort(repeat); // loop count (extra iterations, 0=repeat forever)\r\n\t\t    out.writeByte(0); // block terminator\r\n\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Writes color table\r\n\t\t*/\r\n\t\t\r\n\t\tvar writePalette = function writePalette()/*void*/\r\n\t\t{\r\n\t\t    out.writeBytes(colorTab);\r\n\t\t    var n/*int*/ = (3 * 256) - colorTab.length;\r\n\t\t    for (var i/*int*/ = 0; i < n; i++) out.writeByte(0);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tvar WriteShort = function WriteShort (pValue/*int*/)/*void*/\r\n\t\t{  \t\r\n\t\t\t\r\n\t\t  \tout.writeByte( pValue & 0xFF );\r\n\t\t  \tout.writeByte( (pValue >> 8) & 0xFF);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Encodes and writes pixel data\r\n\t\t*/\r\n\t\t\r\n\t\tvar writePixels = function writePixels()/*void*/\r\n\t\t{\r\n\t\t\t\r\n\t\t    var myencoder/*LZWEncoder*/ = new LZWEncoder(width, height, indexedPixels, colorDepth);\r\n\t\t    myencoder.encode(out);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* retrieves the GIF stream\r\n\t\t*/\r\n\t\tvar stream = exports.stream = function stream ( )/*ByteArray*/\r\n\t\t{\r\n\t\t\t\r\n\t\t\treturn out; \r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tvar setProperties = exports.setProperties = function setProperties(has_start, is_first){\r\n\t\t  started = has_start;\r\n\t\t  firstFrame = is_first;\r\n\t\t  //out = new ByteArray; //??\r\n\t\t}\r\n\t\t\r\n\t\treturn exports\r\n\t\t  \r\n\t}\r\n"]}